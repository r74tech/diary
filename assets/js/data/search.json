[ { "title": "セキュリティ診断AIエージェント「Takumi」世界最速体験会 参加レポート", "url": "/posts/2025-04-08-takumi/", "categories": "Security", "tags": "Security, AI", "date": "2025-04-08 00:00:00 +0900", "snippet": "2025年4月7日、GMO Flatt Securityが主催する『セキュリティ診断AIエージェント「Takumi」世界最速体験会』に参加してきました。このイベントでは、3月に提供開始された日本初のセキュリティ診断AIエージェント「Takumi」の実力を体験するといったものでした。TakumiとはTakumiは、GMO Flatt Securityが提供する、セキュリティ診断に特化したAIエ...", "content": "2025年4月7日、GMO Flatt Securityが主催する『セキュリティ診断AIエージェント「Takumi」世界最速体験会』に参加してきました。このイベントでは、3月に提供開始された日本初のセキュリティ診断AIエージェント「Takumi」の実力を体験するといったものでした。TakumiとはTakumiは、GMO Flatt Securityが提供する、セキュリティ診断に特化したAIエージェントです。スライドから、Takumiは次のような階層構造で設計されていることがわかります。 “Brain” Layer: Claude Sonnet 3.7を基盤として、Plan、Command、Execute、Observe、Reportといった機能 Execution Layer: Semantic Code Search、Browsing Web、Knowledge、API Integrationなどの機能 View tweet on Twitter 特筆すべきは、Takumiが単なるLLMのラッパーではなく、セキュリティタスクのために特別に設計・調整されたエージェントであるという点です。モデルの基本性能に加えて、セキュリティ領域特有の要件に応じた様々な補正や拡張が施されています。開発背景と現状セキュリティ診断はこれまで完全に自動化することが難しい領域とされてきましたが、最新のLLMの能力向上により、実用レベルの精度で脆弱性を検出できるようになったことが開発の背景にあるようです。特に複雑なビジネスロジックの脆弱性や、コードの文脈を理解した上での脆弱性診断などは、従来のツールでは捉えきれなかった部分です。既にプロダクション環境でも活用されており、社内での実用も進んでいるとのこと。特に注目すべきは、実際の顧客環境（同意を得た上で）でも脆弱性診断に活用されているという点で、その実用性が証明されつつあります。特徴的な機能思考プロセスの可視化処理中の思考過程をリアルタイムで表示する機能があります。セキュリティという重要領域では、AIの判断過程が「ブラックボックス」になることを避け、透明性を確保することが重要です。この機能により、どのようにセキュリティ判断が行われているかを追跡できます。タスクスケジューリング定期的なタスク実行機能も実装されており、「1日1回これを実行」「1時間後にこれを実行」といった指示が可能です。これにより、定期的なセキュリティレビューの自動化が実現します。チャンネルごとの独立した知識管理企業での利用を想定し、Slackのチャンネルごとに独立して存在する設計になっています。これは異なるプロジェクトやチーム間での情報の混在を防ぎ、コンテキストの分離を実現するための工夫です。ナレッジ機能特定の調査結果や情報を選択的に記憶させる「ナレッジ」機能も実装されています。これにより、効率的な知識管理と再利用が可能になります。DevinとTakumiの比較イベントでは、AIエージェントの使い分けについても言及があり、特に開発特化型AIエージェント「Devin」との比較が興味深く、印象に残っています。Devin 高速なレスポンス コードを書く・改造する能力に優れる 素早く回答する傾向Takumi コードを深く読み解く能力に優れる セキュリティ観点からコードは改ざんしない方針 丁寧に検討して回答（Deep Research型）タスクごとに最適化が必要であり、Devinのような開発支援エージェントは迅速な対応とは対照的に、Takumiはセキュリティタスクという性質上、より慎重で深い分析が求められるため、じっくりと時間をかけて考えるスタイルになっているようです。こうした比較から、AIエージェントは汎用的な「何でもできる」存在よりも、特定のタスクに最適化された専門家としての役割が現状では効果的であることが示唆されました。将来的には統合される可能性もありますが、現時点では目的に応じたエージェントの使い分けが重要という見解でした。アクティブなセキュリティモニタリング体験会で触れたTakumiはユーザーからの問いかけに応答する受動的な設計でしたが、「アクティブTakumi」と呼べるような、より能動的に行動するバージョンが顧客に提供されるということも紹介されました。例えば、新しいプルリクエストの自動レビューや、新規デプロイされたコードの脆弱性チェックなど、定期的または特定のイベントをトリガーにして自動的に動作するような機能を想定しているようです。こうしたアクティブな監視により、セキュリティ問題の早期発見と対応が可能になると考えられます。セキュリティと信頼性Takumi自体のセキュリティと信頼性も重要なテーマです。スライドには「Workspace (Sandbox)」の記載があり、安全な実行環境の確保が強調されていました。また、一時的な認証情報の管理も示されており、セキュリティツールとしての信頼性担保にも配慮されています。セキュリティ診断を行うツール自体が脆弱であってはならないという当然の要件を満たすために、様々な対策が講じられているようです。今後のイベント他にも、次回イベントの予告がありました。これは開発特化AIエージェントであるDevinとTakumiの対決をテーマにしたイベントで、4月22日に開催予定とのことです。 View tweet on Twitter 詳しくはこちらをご確認ください。実際のTakumiの体験会イベントでは、参加者が実際にTakumiを使ってセキュリティ診断を行う体験会が行われました。私もSlack上でTakumiと対話し、その実力を試してみることにしました。Takumiへの脆弱性診断依頼私はTakumiに対して「badtodoアプリケーションのXSS脆弱性を徹底的に分析してください」と依頼しました。依頼時には以下のような手順を指定しました。 まずアプリケーションのファイル構造と主要なPHPファイルを分析し、ユーザー入力を受け付ける箇所を特定 特にTODOの追加フォームなどでユーザー入力がどのように処理されているか詳しく調査（入力のサニタイズ、バリデーション、出力時のエスケープ処理などの確認）Takumiの分析プロセスTakumiはすぐに分析を開始し、進捗状況を定期的に報告してくれました。まず、badtodoディレクトリの構造を確認し、基本的なファイル構成を把握しました。次に主要なPHPファイルを特定し、以下のファイルを詳細に分析していました。 common.php（共通関数、データベース接続など） template.php（HTMLテンプレート） logindo.php（ログイン処理） addtodo.php（TODOの追加処理） todolist.php（TODO一覧表示） todo.php（TODO詳細表示） badapp.php（アプリケーションのコア機能）Takumiは「In my brain (recent 3 thoughts):」というラベルで思考過程を可視化しており、分析の方向性や着目しているポイントをリアルタイムで確認できるのが興味深かったです。これにより、AIの判断がブラックボックス化せず、その判断根拠を追跡できます。発見された脆弱性分析の結果、Takumiは以下の潜在的XSS脆弱性ポイントを特定しました。 todo.php (43-46行目)メモ欄のURLをリンクに変換する際の不十分なエスケープ処理 $memo = nl2br(h($result['memo']));$memo = preg_replace('!https?://[a-zA-Z0-9\\\\+\\\\$\\\\;\\\\?\\\\%,!#*/:@&amp;=_-]+!', '&lt;a href=\"${0}\"&gt;${0}&lt;/a&gt;', $memo);echo $memo; proxy.phpユーザー入力URLの不適切な処理 $url = filter_input(INPUT_GET, \"url\");$output = curl_exec($ch);echo $output; badapp.php (form/aメソッド)フォーム生成時のパラメータエスケープ不足 $result .= \"&lt;form action='$url' method='\" . ($post_method ? 'post' : 'get') . \"'\";$r[] = \"&lt;input type='hidden' name='$key' value='$value'&gt;\"; Takumiは次のステップとして、見つかった脆弱性ポイントの詳細分析、OWASPガイドラインに基づく脆弱性検証、XSS攻撃ペイロードのテスト計画策定を提案していました。Takumiの特徴的な機能 思考プロセスの可視化「In my brain」セクションで、Takumiが考えていることをリアルタイムで表示。例えば「badapp.phpをチェックして、アプリケーションのコア機能を把握するよ！」「OWASPルールに沿ってXSS脆弱性をチェックしていくよ！」といった思考が表示され、分析の方向性を理解できます。 進捗報告機能「現在の状態を教えて」と尋ねると、現在までの分析状況を詳細に報告してくれます。 Markdown形式でのレポート生成中間報告や最終報告をMarkdown形式で整理されたドキュメントとして提供。コードブロックや見出しを適切に使用し、非常に読みやすいレポートを生成します。 アクションプラン提案発見した脆弱性の検証方法や修正案も含めた次のステップを提案してくれるため、単に問題を指摘するだけでなく、解決への道筋も示してくれます。 まとめ今回のTakumi世界最速体験会を通じて、AIによるセキュリティ診断の可能性と実用性を実感することができました。特に印象的だったのは、単なる脆弱性のスキャンツールとしてではなく、コードの文脈を理解し、思考プロセスを可視化しながら分析を進める「協働者」としての側面です。セキュリティの専門家不足が課題となる中、Takumiのようなツールがその隙間を埋めるポテンシャルを感じました。もちろん、人間のセキュリティ専門家に取って代わるものではありませんが、初期スクリーニングや日常的なコードレビューの強化に大きく貢献できると考えます。4月22日のイベントでは、開発とセキュリティのAIエージェント対決という形で、さらに興味深い展開が期待できそうだと感じました。" }, { "title": "CRTP (Certified Red Team Professional) Certification Experience", "url": "/posts/2025-03-23-crtp-certification-experience/", "categories": "Experience", "tags": "CRTP, Security, Offensive Security, Red Team", "date": "2025-03-23 00:00:00 +0900", "snippet": "はじめにCRTP（Certified Red Team Professional）試験を最近受験し、合格することができました。この体験記では、試験準備から実技、レポート作成までの実際の経験と、これから受験する方へのアドバイスを詳しく共有します。試験の背景CRTPはAltered Securityが提供するハンズオン形式の資格試験です。費用は$249で、これには30日間のラボアクセスと1回の試...", "content": "はじめにCRTP（Certified Red Team Professional）試験を最近受験し、合格することができました。この体験記では、試験準備から実技、レポート作成までの実際の経験と、これから受験する方へのアドバイスを詳しく共有します。試験の背景CRTPはAltered Securityが提供するハンズオン形式の資格試験です。費用は$249で、これには30日間のラボアクセスと1回の試験機会が含まれています。再受験が必要な場合は$99です。試験は24時間の実技試験と、その後24時間のレポート作成から構成されています。Nikhil Mittal氏の教材は非常に分かりやすく、Active Directoryの基礎から高度な攻撃手法まで網羅的に解説されています。準備のための詳細なアプローチ学習方法の最適化 体系的なノート作成: 各攻撃テクニックについて以下の情報を整理しました。 攻撃の目的と達成できること 脆弱性の本質と攻撃が可能な理由 攻撃の具体的な手順と必要なツール コマンド例と成功/失敗時のメッセージパターン マニュアルの最終確認: 試験直前に（試験当日の深夜0時から4時まで）PowerShellのマニュアルを1周し、どのセクションにどの情報があるかを再確認しました。これは試験中に非常に役立ちました。 チートシートの作成: モジュールのインポートからフォレスト間の権限昇格まで、すべての重要なコマンドを記録したチートシートを作成しました。これにより試験中にコマンドをコピー＆ペーストするだけで素早く操作できました。言語の準備英語に不安がある場合は、ラボを開始する前に重要な部分を翻訳しておくことをお勧めします。特に技術用語や手順の説明は事前に理解しておくと、試験中のストレスが大幅に軽減されます。試験環境のセットアップと管理効率的な環境構築試験開始後の1時間で、最初にボリュームマウントを設定し、必要なツールをすべてアップロードしておくことが重要です。その後はブラウザからRDPで接続すれば、スムーズに作業を進めることができます。トラブルシューティングラボ環境が反応しなくなった場合の対処法。 パニックにならず、ダッシュボードは開いたまま15分ほど待ちましょう 自動的に再起動しない場合は、再起動ボタンを押してみてください それでも解決しない場合は、即座にサポートに連絡してください私の場合、8時間ほど実技を行った後に環境のリセットを行ったところ、環境が起動できなくなりました。サポートに問い合わせた結果、復旧することができ、その後3時間で攻略することができました。私の実際の試験体験タイムライン 試験日深夜0時〜4時: PowerShellマニュアルを1周 朝6時: 試験開始 最初の1時間: 初期アクセスからローカル管理者権限の奪取 2時間目: 1台目のサーバーを完全に攻略 その後数時間: 順調に2台目まで攻略 6時間経過時点: 3台目の攻略で詰まってしまい、環境のリセットを実行 リセット後: 環境が起動せず、疲労により2時間ほど仮眠 14時頃: 起床後もリセットされておらず、サポートに問い合わせ 17時: 環境復旧、再開 20時頃: 全サーバーの攻略完了 翌日: 6時間かけてレポート作成実際の苦労と対処法睡眠不足と長時間の連続作業は思考能力に影響を与えます。私の経験からアドバイスするなら、試験前の十分な休息と、試験中の適切な休憩が非常に重要です。疲れを感じたら短い仮眠をとることも効果的です。効果的な証拠収集と記録試験中は以下の情報を徹底的に記録することが重要です。 実行した各ステップの詳細 使用したコマンドとその出力結果 重要な画面のスクリーンショット（多ければ多いほど良い） 可能であれば操作の動画記録これらの情報はレポート作成時に非常に役立ちます。特にスクリーンショットは「多すぎる」ということはありません。レポート作成Sysreptorの活用レポート作成にはSysreptorを使用しました。このツールは専門的なペネトレーションテストレポートを効率的に作成するのに最適です。デモレポートにあるテンプレートを参考にすることで、流れに沿ってレポートを作成することができました。レポートの構成私の最終レポートは56ページにおよび、そのうち攻撃ツールの詳細な解説に12ページを割きました。レポートは次のような主要セクションで構成されていました。 エグゼクティブサマリー（概要、発見された誤構成、推奨事項、結論） 方法論（目的、範囲、提供されたユーザーアカウントとマシン） 侵害パス（各ターゲットシステムごとの詳細な攻撃手法） 免責事項 付録（Active Directoryセキュリティ評価ツール）各攻撃パスごとに以下の情報を詳細に記載しました。 脆弱性/誤構成の詳細: 具体的な問題点とその技術的背景 影響度: 組織のセキュリティにどのような影響があるか 再現手順: スクリーンショット付きの詳細なステップバイステップガイド 証拠: コマンド出力、ハッシュ、フラグなど 推奨される対策: 問題を修正するための具体的な方法時間管理の重要性レポート作成には私の場合6時間ほどかかりましたが、これは事前にスクリーンショットや実行コマンドを詳細に記録していたからこそ可能でした。証拠不足でレポート作成に苦労することがないよう、試験中の記録は徹底的に行いましょう。試験の実際とアドバイス効果的な列挙CRTPの成功の鍵は徹底的な列挙にあります。以下の列挙ポイントを重点的に確認しました。 ドメインコントローラー情報 ユーザーアカウントとグループ 信頼関係（ドメイン間、フォレスト間） サービスアカウント グループポリシー 共有フォルダとACL Kerberos委任設定困難に直面したとき途中で詰まった場合は、以下のアプローチが有効です。 基本に立ち返り、これまでの列挙結果を再確認する 別のアングルからの攻撃を試みる 一旦休息をとり、頭をリフレッシュする私自身、3台目のサーバーで詰まった際に環境のリセットを試みましたが、それがかえって問題を複雑にしてしまいました。リセットは最終手段として、まずは異なるアプローチを試すことをお勧めします。最終的な学びCRTP試験を通じて、Active Directory環境における攻撃手法だけでなく、以下のスキルも向上しました。 体系的な問題解決能力 トラブルシューティングスキル レポート作成能力 時間管理とプロジェクト計画 ストレス下での冷静な判断力特に、試験中の睡眠不足が思考能力に与える影響を実感しました。適切な休息と集中力の管理が、長時間に及ぶ試験では極めて重要です。おわりにCRTPは実践的な資格であり、Active Directoryセキュリティを学ぶ上で非常に価値のある投資です。十分な準備と計画的なアプローチで、皆さんもきっと合格できるでしょう。最後に、試験のポイントをまとめます。 事前にPowerShellツールと攻撃手法に慣れておく 十分な休息をとってから試験に臨む 詳細な列挙を徹底し、攻撃ベクトルを特定する 試験中に詳細なスクリーンショットと記録を取る 問題が発生したらパニックにならず、サポートに連絡する レポート作成には十分な時間をかけ、専門的な品質を目指す皆さんの挑戦を応援しています！" }, { "title": "DuckDBとCodeMirrorを使って青空文庫のデータを検索する", "url": "/posts/2024-12-19-aozora-duckdb/", "categories": "web", "tags": "duckdb", "date": "2024-12-19 00:00:00 +0900", "snippet": "脆弱エンジニアの Advent Calendar 2024 19日目の記事です。謝辞本プロジェクトは@voluntasさんのduckdb-wasm-parquetを参考にさせていただきました。この場を借りて感謝申し上げます。ライセンス情報 (クリックで展開)This product includes software developed by @voluntas (duckdb-wasm-p...", "content": "脆弱エンジニアの Advent Calendar 2024 19日目の記事です。謝辞本プロジェクトは@voluntasさんのduckdb-wasm-parquetを参考にさせていただきました。この場を借りて感謝申し上げます。ライセンス情報 (クリックで展開)This product includes software developed by @voluntas (duckdb-wasm-parquet). Licensed under the Apache License, Version 2.0.TL;DR青空文庫データ分析ツールを作成しました。DuckDBとCodeMirrorを使って、青空文庫のデータをブラウザ上で検索・分析できるようにしました。はじめに青空文庫には多くの無料で読める文学作品が収録されていますが、大量のデータから特定の作品や著者を効率的に検索したり、データを分析したりするのは容易ではありません。この記事では、ブラウザ上で動作する軽量データベースエンジン DuckDB とインタラクティブなコードエディタ CodeMirror を組み合わせて、青空文庫のデータを快適に検索・分析できるツールを構築する方法を解説します。DuckDBとはDuckDBは、分析用に設計された組み込み型SQLデータベースエンジンです。PostgreSQLに似た文法を持ちながら、より分析処理に特化した機能を提供します。主な特徴 アナリティクス指向のアーキテクチャ 列指向ストレージエンジンによる高速な分析処理列指向ストレージエンジンは、列ごとにデータを格納することで、必要な列のみを効率的に読み取ることができます。これにより、大規模なデータセットに対してもメモリ使用量を抑えつつ、高速に分析処理を行えます1。 ベクトル化実行エンジンによる効率的なクエリ処理ベクトル化実行エンジンは、データをチャンク単位で処理し、CPUキャッシュの効率を最大化します2。 OLAP（Online Analytical Processing）ワークロードに最適化OLAP向けのクエリ処理は、大量のデータの集計や分析を短時間で行うことを目指しています。 SQLインジェクション対策の実装パラメータ化されたクエリの採用により、SQLインジェクションのリスクを最小限に抑えた設計となっています3。 トランザクションサポート ACID準拠のトランザクションデータベースがAtomicity, Consistency, Isolation, Durabilityを満たすことで、信頼性の高いデータ処理を保証します4。 スナップショットアイソレーション複数のトランザクションが並行して実行されても、一貫した結果を提供します5。 WebAssembly版の特徴DuckDB-WASMは、ブラウザ上で動作するDuckDBの実装です。 完全なクライアントサイド処理 サーバーレスでの分析が可能 ネットワーク遅延なしでのクエリ実行 プライバシー保護（データがローカルで処理される）6 ブラウザストレージとの統合 File System Access API対応7 IndexedDBを使用したデータの永続化 OPFS（Origin Private File System）サポート8 Parquet形式との連携DuckDBは Apache Parquet 形式との親和性が高く、以下の利点があります。 列指向フォーマットによる効率的なデータ格納 高い圧縮率によるストレージ効率の向上 スキーマ情報の保持による型安全性 必要な列のみを読み込むことによる高速化CodeMirrorについてCodeMirrorは、プログラマブルなテキストエディタを実現するためのTypeScriptライブラリです。バージョン6から完全に再設計され、より高度な機能と柔軟性を提供しています。主要機能 最新のエディタ機能 ユニコード対応 双方向テキストのサポート モバイルデバイスへの対応 カスタマイズ可能なキーバインディング プログラミング言語サポート 200以上の言語に対応 SQLの高度な構文ハイライト リアルタイムの構文エラー検出 オートコンプリート機能 拡張システム State Field API による状態管理 Compartments による拡張の分離 View Plugins によるUI拡張 Facet による設定の管理 SQLエディタとしての利用CodeMirrorをSQLエディタとして活用する際の主な設定項目。const editor = new EditorView({ state: EditorState.create({ doc: DEFAULT_SQL, extensions: [ sql(), // SQLサポート basicSetup, // 基本機能セット EditorView.lineWrapping, // 行折り返し EditorState.readOnly.of(false), // 編集可能設定 // SQLに特化したスタイル設定 EditorView.theme({ \"&amp;\": { height: \"400px\", maxWidth: \"100%\" }, \".cm-content\": { fontFamily: \"monospace\" } }) ] })});パフォーマンス特性 仮想DOM不使用: 直接DOMを操作し高速なレンダリング インクリメンタルパース: 変更された部分のみを再解析 レイジーローディング: 必要な機能のみを読み込みデータ処理の詳細青空文庫のテキスト形式青空文庫のテキストには、以下のような特殊な形式が含まれています。 ルビ（読み仮名） 例: 零時半《れいじはん》 例: 桜《さくら》の花 注記 例: ［＃ここから２字下げ］ 例: ［＃「」は縦線付きの七重鉤括弧、第３段］ テキストクリーニングルビの処理def remove_ruby(text: str) -&gt; str: \"\"\"ルビを削除する関数\"\"\" # 漢字《よみがな》形式のルビを削除 text = re.sub(r'([^《]*)《[^》]*》', r'\\1', text) return textこの関数は以下のように動作します。 零時半《れいじはん》 → 零時半 桜《さくら》の花 → 桜の花完全なテキストクリーニングdef clean_text(text: Optional[str]) -&gt; Optional[str]: \"\"\"テキストをクリーンアップする関数\"\"\" if text is None: return None # Unicode正規化（NFKC） text = unicodedata.normalize('NFKC', text) # ルビの削除 text = remove_ruby(text) # 制御文字の除去（改行は保持） text = ''.join(char for char in text if char == '\\n' or unicodedata.category(char)[0] != 'C') # 注記の削除 text = re.sub(r'［＃[^］]*］', '', text) # 改行の正規化 text = text.replace('\\r\\n', '\\n').replace('\\r', '\\n') # 連続する空白や改行を1つに text = re.sub(r'\\n\\s*\\n', '\\n\\n', text) text = re.sub(r'[ \\t]+', ' ', text) return text.strip()Parquetファイルへの変換と分割データ処理の最終段階として、クリーニングしたテキストをParquet形式に変換し、扱いやすいサイズに分割します。def split_parquet_file(input_file: str, output_dir: str = \"splits\"): \"\"\"Parquetファイルを60MB単位で分割する\"\"\" con = duckdb.connect() # 総行数の取得 total_rows = con.execute( \"SELECT COUNT(*) FROM read_parquet(?)\", [input_file] ).fetchone()[0] # 6分割（各60MB程度） rows_per_chunk = total_rows // 6 for i in range(6): output_file = f'aozora_combined_part{i:02d}.parquet' # 分割してエクスポート con.execute(f\"\"\" COPY ( SELECT * FROM read_parquet('{input_file}') LIMIT {rows_per_chunk} OFFSET {i * rows_per_chunk} ) TO '{output_file}' (FORMAT 'parquet', COMPRESSION 'zstd') \"\"\")アプリケーションの実装このアプリケーションは、青空文庫のデータをParquetファイルから読み込み、DuckDB WASTを使用してブラウザ上でSQLクエリを実行できるようにします。DuckDBの初期化とデータロード// DuckDBの初期化const worker = new duckdb_worker()const logger = new duckdb.ConsoleLogger()const db = new duckdb.AsyncDuckDB(logger, worker)await db.instantiate(duckdb_wasm)async function loadParquetParts(db) { const baseUrl = import.meta.env.BASE_URL || '/'; const totalParts = 6; try { const conn = await db.connect(); for (let i = 0; i &lt; totalParts; i++) { // OPFSからバッファを取得を試みる let buffer = await getBufferFromOPFS(i); // キャッシュにない場合はダウンロード if (!buffer) { const partUrl = new URL( `${FILE_NAME_PREFIX}${i.toString().padStart(2, '0')}.parquet`, window.location.origin + baseUrl ).href; // ダウンロードとプログレス表示の処理 const response = await fetch(partUrl); // ... ストリーム処理とプログレス更新 ... // OPFSへの保存 await saveStreamToOPFS(stream, i); buffer = await getBufferFromOPFS(i); } // DuckDBへの登録 await db.registerFileBuffer(`part${i}.parquet`, new Uint8Array(buffer)); // テーブルの作成または追加 if (i === 0) { await conn.query(` CREATE TABLE aozora_combined AS SELECT * FROM read_parquet('part0.parquet'); `); } else { await conn.query(` INSERT INTO aozora_combined SELECT * FROM read_parquet('part${i}.parquet'); `); } } } catch (error) { throw error; }}検索機能の実装// 基本検索機能searchInput?.addEventListener('input', async () =&gt; { const searchTerm = searchInput.value.trim() if (!searchTerm) { const resultElement = document.getElementById('result') if (resultElement) resultElement.innerHTML = '' return } const conn = await db.connect() try { const result = await conn.query(` SELECT 作品名, 姓 || ' ' || 名 as 著者名, 公開日 FROM aozora_combined WHERE 作品名 LIKE '%${searchTerm}%' OR 姓 LIKE '%${searchTerm}%' OR 名 LIKE '%${searchTerm}%' LIMIT 100; `) displayResults(result) } finally { await conn.close() }})// 著者統計document.getElementById('author-stats')?.addEventListener('click', async () =&gt; { const conn = await db.connect() try { const result = await conn.query(` SELECT 姓 || ' ' || 名 as 著者名, COUNT(*) as 作品数, MIN(公開日) as 最初の公開日, MAX(公開日) as 最新の公開日 FROM aozora_combined GROUP BY 姓, 名 ORDER BY 作品数 DESC LIMIT 20; `) displayResults(result) } finally { await conn.close() }})まとめ本プロジェクトでは、DuckDBとCodeMirrorを組み合わせることで、以下を実現しました。 ブラウザ上での高速なテキストデータ検索 インタラクティブなSQLクエリ実行環境 サーバーレスでの大規模テキストデータ分析コードaozora-duckdbにて、本プロジェクトのソースコードを公開しています。ライセンス本プロジェクトはApache License 2.0の下で公開されています。 DuckDB Documentation: File Formats &#8617; DuckDB Documentation: Execution Format &#8617; 非脆弱 &#8617; ACID Compliance: Changing Data with Confidence and ACID &#8617; Snapshot Isolation &#8617; DuckDB WASM: Running in the Browser &#8617; File System Access API: MDN Web Docs &#8617; OPFS Support: OPFS API Overview &#8617; " }, { "title": "[wip] Damn Vulnerable Kubernetes Application Challenge-1 Writeup", "url": "/posts/2024-10-22-dvka01/", "categories": "wip", "tags": "wip, writeup", "date": "2024-10-22 00:00:00 +0900", "snippet": "", "content": "" }, { "title": "[wip] とある海豹とSecurity-JAWS #01 Writeup", "url": "/posts/2024-09-21-azasecjaws01/", "categories": "wip", "tags": "wip, ctf, writeup", "date": "2024-09-21 00:00:00 +0900", "snippet": "はじめに2024年9月21日、「とある海豹とSecurity-JAWS #01」というAWSのS3セキュリティに焦点を当てたCTFイベントに参加しました。このイベントでは、S3のファイルアップロード機能に潜む脆弱性を探ることがテーマで、特にContent-Typeヘッダの操作によるXSS脆弱性を発見していくというものでした。イベントの主なテーマ: S3のファイルアップロード時におけるCon...", "content": "はじめに2024年9月21日、「とある海豹とSecurity-JAWS #01」というAWSのS3セキュリティに焦点を当てたCTFイベントに参加しました。このイベントでは、S3のファイルアップロード機能に潜む脆弱性を探ることがテーマで、特にContent-Typeヘッダの操作によるXSS脆弱性を発見していくというものでした。イベントの主なテーマ: S3のファイルアップロード時におけるContent-Typeヘッダの制御 任意のファイル形式のアップロード可否の検証本記事では、このCTFで解いた問題と、その過程で学んだポイントを紹介します。一部の問題は未解決なため全てではないですが、学びを共有しようと思います。Writeup構成概要今回のCTFで提供された構成は、以下の図に示すようなものでした。また、以下のようなターゲットページが用意されており、指定されたS3のURLを入力し、Cookieを付与した状態でそのURLにアクセスする仕組みです。動作の概要 ユーザは、悪意のあるHTMLファイルをアップロードします。 アップロードされたファイルはS3に保存されます。 アプリケーションがS3のURLを用いてアクセスを行い、特定のクッキー（フラグ）が付与された状態でターゲットのページにアクセスします。 クローラーがそのページのHTMLを取得し、結果をS3バケットに保存します。 S3バケットに保存されたHTMLは、iframeを使って最終的に表示されます。クローラーの実装クローラーは、指定されたURLにアクセスし、フラグが埋め込まれたクッキーを付与した後、そのページのHTMLを取得し、S3に保存します。export const crawler = async (url: string) =&gt; { const browser = await launch({ headless: true, // ヘッドレスブラウザモードで起動 args: puppeteerArgs, }); const page = await browser.newPage(); page.setCookie({ name: \"flag\", value: process.env.FLAG || \"flag{dummy}\", // フラグの値 domain: process.env.DOMAIN || \"example.com\", // 対象ドメイン }); await page.goto(url); // 指定URLへアクセス await new Promise((resolve) =&gt; setTimeout(resolve, 500)); // ページのロード待機 const bodyHandle = await page.$(\"body\"); const html = await page.evaluate((body) =&gt; { if (!body) return \"HTML is empty\"; return body.innerHTML; }, bodyHandle); const path = new URL(url).pathname; await uploadToS3(`delivery/${path.split(\"/\").pop()}`, Buffer.from(html)); // S3にHTMLを保存 await browser.close();};IntroductionServer Side Uploadこの問題は、S3のファイルアップロード機能を活用し、任意のファイルをアップロードする構成となっています。以下は、サーバーサイドでのファイルアップロードの実装です。server.post('/api/upload', async (request, reply) =&gt; { const data = await request.file({ limits: { fileSize: 1024 * 1024 * 100, // 最大ファイルサイズ: 100MB files: 1, // 一度にアップロードできるファイル数: 1つ }, }); if (!data) { return reply.code(400).send({ error: 'No file uploaded' }); // エラーレスポンス: ファイルがアップロードされていない場合 } const filename = uuidv4(); // ランダムなファイル名を生成 const s3 = new S3Client({}); const command = new PutObjectCommand({ Bucket: process.env.BUCKET_NAME, // バケット名 Key: `upload/${filename}`, // アップロード先のファイルパス Body: data.file, // アップロードするファイル本体 ContentLength: data.file.bytesRead, // ファイルのサイズ ContentType: data.mimetype, // ファイルのMIMEタイプ }); await s3.send(command); // S3にファイルをアップロード reply.send(`/upload/${filename}`); // アップロードされたファイルのURLを返却 return reply;});以下のようなHTMLファイルをアップロードすることで、flagを取得できます。&lt;html lang=\"en\"&gt; &lt;body&gt; &lt;p id=\"flag-container\"&gt;Flag: Loading...&lt;/p&gt; &lt;script&gt; // クッキーから \"flag\" を抽出し、要素に表示する document.getElementById('flag-container').textContent = document.cookie.split(';').find(c =&gt; c.includes('flag')).split('=')[1]; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;Pre Signed Upload" }, { "title": "QuinnでQUICを試す", "url": "/posts/2024-07-18-rust-quinn-test/", "categories": "dev", "tags": "web, rust", "date": "2024-07-18 00:00:00 +0900", "snippet": "参考記事: https://tech.aptpod.co.jp/entry/2020/12/04/100000https://github.com/r74tech/quinn-example.├── Cargo.toml└── src ├── client.rs ├── common.rs ├── main.rs └── server.rs[package]name ...", "content": "参考記事: https://tech.aptpod.co.jp/entry/2020/12/04/100000https://github.com/r74tech/quinn-example.├── Cargo.toml└── src ├── client.rs ├── common.rs ├── main.rs └── server.rs[package]name = \"quinn-example\"version = \"0.1.0\"edition = \"2021\"# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html[[bin]]name = \"server\"path = \"src/server.rs\"[[bin]]name = \"client\"path = \"src/client.rs\"[dependencies]anyhow = \"1.0\"quinn = \"0.10\"tokio = { version = \"1.38\", features = [\"full\"] }futures = \"0.3\"rcgen = \"0.12\"rand = \"0.8\"rustls = { version = \"0.21\", features = [\"dangerous_configuration\"] }use anyhow::Result;mod common;fn main() -&gt; Result&lt;()&gt; { let (cert_der, key_der) = common::generate_self_signed_cert()?; common::save_cert_and_key(&amp;cert_der, &amp;key_der)?; Ok(())}use quinn::{ClientConfig, ServerConfig, TransportConfig};use rustls::{Certificate, PrivateKey};use std::net::{IpAddr, Ipv4Addr, SocketAddr};use std::sync::Arc;use anyhow::*;pub const SERVER_PORT: u16 = 5000;pub const SERVER_CERT_PATH: &amp;str = \"cert.der\";pub const SERVER_KEY_PATH: &amp;str = \"key.der\";pub fn generate_self_signed_cert() -&gt; Result&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt; { let cert = rcgen::generate_simple_self_signed(vec![\"localhost\".into()])?; let cert_der = cert.serialize_der()?; let priv_key = cert.serialize_private_key_der(); Ok((cert_der, priv_key))}pub fn save_cert_and_key(cert_der: &amp;[u8], key_der: &amp;[u8]) -&gt; Result&lt;()&gt; { std::fs::write(SERVER_CERT_PATH, cert_der)?; std::fs::write(SERVER_KEY_PATH, key_der)?; Ok(())}pub fn load_cert_and_key() -&gt; Result&lt;(Vec&lt;u8&gt;, Vec&lt;u8&gt;)&gt; { let cert_der = std::fs::read(SERVER_CERT_PATH)?; let key_der = std::fs::read(SERVER_KEY_PATH)?; Ok((cert_der, key_der))}pub fn configure_server(cert_der: Vec&lt;u8&gt;, priv_key: Vec&lt;u8&gt;) -&gt; Result&lt;ServerConfig&gt; { let mut server_config = ServerConfig::with_single_cert( vec![Certificate(cert_der)], PrivateKey(priv_key) )?; server_config.transport = Arc::new(TransportConfig::default()); Ok(server_config)}pub fn configure_client(cert_der: Vec&lt;u8&gt;) -&gt; Result&lt;ClientConfig&gt; { let mut roots = rustls::RootCertStore::empty(); roots.add(&amp;Certificate(cert_der))?; let client_config = ClientConfig::new(Arc::new( rustls::ClientConfig::builder() .with_safe_defaults() .with_root_certificates(roots) .with_no_client_auth() )); Ok(client_config)}pub fn get_server_addr() -&gt; SocketAddr { SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), SERVER_PORT)}use anyhow::*;use quinn::{Endpoint, Connection};use tokio::io::AsyncReadExt;use std::result::Result::Ok;mod common;#[tokio::main]async fn main() -&gt; Result&lt;()&gt; { let (cert_der, _) = common::load_cert_and_key()?; let client_config = common::configure_client(cert_der)?; let mut endpoint = Endpoint::client(\"0.0.0.0:0\".parse()?)?; endpoint.set_default_client_config(client_config); let server_addr = common::get_server_addr(); let connection = endpoint.connect(server_addr, \"localhost\")?.await?; println!(\"Connected to {}\", connection.remote_address()); run_client(connection).await?; endpoint.wait_idle().await; Ok(())}async fn run_client(connection: Connection) -&gt; Result&lt;()&gt; { loop { println!(\"Enter a message (or 'quit' to exit):\"); let mut input = String::new(); std::io::stdin().read_line(&amp;mut input)?; let message = input.trim(); if message == \"quit\" { break; } let response = send_message(&amp;connection, message).await?; println!(\"Server response: {}\", response); } connection.close(0u32.into(), b\"Done\"); Ok(())}async fn send_message(connection: &amp;Connection, message: &amp;str) -&gt; Result&lt;String&gt; { let (mut send, mut recv) = connection.open_bi().await?; send.write_all(message.as_bytes()).await?; send.finish().await?; let mut response = String::new(); recv.read_to_string(&amp;mut response).await?; Ok(response)}use anyhow::*;use quinn::{Endpoint, Connection};use std::net::{SocketAddr, IpAddr, Ipv4Addr};use std::result::Result::Ok;mod common;#[tokio::main]async fn main() -&gt; Result&lt;()&gt; { let (cert_der, priv_key) = common::load_cert_and_key()?; let server_config = common::configure_server(cert_der, priv_key)?; let addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), common::SERVER_PORT); let endpoint = Endpoint::server(server_config, addr)?; println!(\"Listening on {}\", endpoint.local_addr()?); run_server(endpoint).await}async fn run_server(endpoint: Endpoint) -&gt; Result&lt;()&gt; { while let Some(conn) = endpoint.accept().await { tokio::spawn(async move { match conn.await { Ok(connection) =&gt; { println!(\"Connection established from: {}\", connection.remote_address()); if let Err(e) = handle_connection(connection).await { eprintln!(\"Connection error: {}\", e); } } Err(e) =&gt; eprintln!(\"Connection failed: {}\", e), } }); } Ok(())}async fn handle_connection(connection: Connection) -&gt; Result&lt;()&gt; { while let Ok((mut send, mut recv)) = connection.accept_bi().await { let mut buf = Vec::new(); while let Some(chunk) = recv.read_chunk(1024, false).await? { buf.extend_from_slice(&amp;chunk.bytes); } println!(\"Received: {}\", String::from_utf8_lossy(&amp;buf)); send.write_all(&amp;buf).await?; send.finish().await?; } Ok(())}$ cargo run --bin quinn-example$ cargo run --bin server$ cargo run --bin client" }, { "title": "[wip] Active Directoryの構築 4 (ADFS 中編)", "url": "/posts/2024-06-11-acrive-directory-4-adfs/", "categories": "wip", "tags": "wip, Active Directory", "date": "2024-06-11 00:00:00 +0900", "snippet": "AD FS構築2. AD FSの機能を有効化する 右上の「管理」&gt; 「役割と機能の追加」をクリックする 「役割と機能の追加ウィザード」が表示されるので、「次へ」をクリックする 「インストールの種類」で「役割ベースまたは機能ベースのインストール」を選択し、「次へ」をクリックする 「サーバーの選択」で「サーバー」を選択し、対象のサーバーを...", "content": "AD FS構築2. AD FSの機能を有効化する 右上の「管理」&gt; 「役割と機能の追加」をクリックする 「役割と機能の追加ウィザード」が表示されるので、「次へ」をクリックする 「インストールの種類」で「役割ベースまたは機能ベースのインストール」を選択し、「次へ」をクリックする 「サーバーの選択」で「サーバー」を選択し、対象のサーバーを選択し、「次へ」をクリックする 「役割の選択」で「Active Directory Federation Services」を選択する 「機能の選択」はデフォルトのまま「次へ」をクリックする 「AD FSの概要」が表示されるので、「次へ」をクリックする 「インストールオプション」で「再起動後に自動的に必要なサービスを追加する」はチェックを入れ、「インストール」をクリックする例にもれず、今回はチェックを入れていないが、実際にはチェックを入れることを推奨する インストールが完了すると「構成が必要です。HOSTでインストールが正常に完了しました」と表示されるので、「閉じる」をクリックする Windows Server 2019は、Firewallの設定が必要なため、以下のコマンドを実行して設定を行う Get-NetFirewallRule | ? Name -Match AD FS | Set-NetFirewallRule -Enabled True 参考: Windows Server 2019 AD FS 構築でハマるポイント対策 右上の通知アイコンをクリックし、「展開後の構成タスク」&gt; 「このサーバーにフェデレーションサービスを展開する」をクリックする 「フェデレーションサービスの展開」が表示されるので、「フェデレーションサーバー ファームに最初のサーバーを作成する」を選択し、「次へ」をクリックする 「Active Directoryドメインサービスへの接続」で構成を実行するユーザーを指定する。今回は、事前に作成したr74tech\\ADFSアカウントで権限を付与しているため、このままで問題ない 「SSL証明書の選択」で使用する証明書を選択する。1.5章で手元に用意した証明書を選択する 「フェデレーションサービスの表示名」を入力し、「次へ」をクリックする 「サービスアカウントの指定」で「KDSルートキーの設定が…」と表示されるため、詳細設定をクリックする powershellを管理者権限で起動し、以下のコマンドを実行する Add-KdsRootKey -EffectiveTime ((Get-Date).addhours(-10)) 「サービスアカウントの指定」で「グループ管理サービスアカウントを作成する」を選択し、「アカウント名」に識別しやすい名前(今回はadfs01)を入力し、「次へ」をクリックする 「オプションの確認」で設定内容を確認し、「次へ」をクリックする 「このサーバーは正常に構成されました」と表示されるので、「閉じる」をクリックする https://localhost/adfs/ls/IdpInitiatedSignOn.aspx にアクセスし、AD FSの動作確認を行う" }, { "title": "[wip] Active Directoryの構築 3 (ADFS 前編)", "url": "/posts/2024-06-06-acrive-directory-3-adfs/", "categories": "wip", "tags": "wip, Active Directory", "date": "2024-06-06 00:00:00 +0900", "snippet": "AD FS構築0. AD FSの準備AD FS用のアカウントと、AD FS用のサービスアカウントを作成する AD DS, AD CSの時と同じように、AD FS用のユーザーを作成するここでは、adfsというユーザーを作成する adfsユーザーを右クリックし、「プロパティ」をクリックして、「所属するグループ」タブをクリックする AD FS用のユーザーにはD...", "content": "AD FS構築0. AD FSの準備AD FS用のアカウントと、AD FS用のサービスアカウントを作成する AD DS, AD CSの時と同じように、AD FS用のユーザーを作成するここでは、adfsというユーザーを作成する adfsユーザーを右クリックし、「プロパティ」をクリックして、「所属するグループ」タブをクリックする AD FS用のユーザーにはDomain Adminsを追加する参考: Install the AD FS Role Service AD FS用のサービスアカウントを作成する 1. 証明書の発行 「Windows 管理ツール」&gt;「証明機関」をクリックする 「証明機関」&gt;「r74tech-ADCS-CA(CAの共通名)」&gt;「証明書テンプレート」を右クリックし、「管理」をクリックする 「証明書テンプレート」が表示されるので、「Web サーバー」を右クリックし、「テンプレートの複製」をクリックする 「新しいテンプレートのプロパティ」が表示されるので、「全般」タブで「テンプレート表示名」を入力する「テンプレート名」は表示名で自動的に入力されるため、変更する必要はない「有効期間」、「更新期間」は必要に応じて変更する 「要求処理」タブで、「秘密キーのエクスポートを許可する」にチェックをいれる 「セキュリティ」タブで、「追加」をクリックし、「コンピューター」に対して「登録」権限を付与するこの時、AD FSサービスアカウントは「コンピューター」に含まれないが、使用を許可するためにはこの権限が必要である要検証「適用」をクリックし、テンプレートを保存する 「証明書テンプレート」を右クリックし、「新規作成」&gt; 「発行する証明書テンプレート」をクリックする 先ほど作成したテンプレートを選択し、「OK」をクリックする Certlmを開く Certlm.mscが立ち上がるので、左ペインの「証明書 - ローカル コンピューター」&gt;「個人」&gt;「証明書」を右クリックし、「すべてのタスク」&gt;「新しい証明書の要求」をクリックする 「証明書の要求ウィザード」が表示されるので、「次へ」をクリックする 「証明書の登録ポリシーの選択」で「Active Directory 登録ポリシー」を選択し、「次へ」をクリックする 「証明書の要求」で「この証明書を登録するには情報が不足しています。設定を完了するには、ここをクリックしてください。」をクリックする 「証明書のプロパティ」が表示されるので、「サブジェクト」タブで以下の項目を入力する サブジェクト名: 共通名にAD FSのカスタムドメインのFQDNを入力する: 例: adfs.adfstest01.r74tech.com 別名: DNSにAD FSのカスタムドメインのFQDNを入力する: 例: adfs.adfstest01.r74tech.com 入力が完了したら「適用」をクリックする 「登録」をクリックする 「証明書のインストール」の状態が「成功」になったら「完了」をクリックする Certlmを開き、「証明書 - ローカル コンピューター」&gt;「個人」&gt;「証明書」に証明書が追加されていることを確認する追加された証明書を右クリックし、「全てのタスク」&gt;「エクスポート」をクリックする 「証明書のエクスポートウィザード」が表示されるので、「次へ」をクリックする 「プライベートキーのエクスポート」で「はい、秘密キーをエクスポートします」を選択し、「次へ」をクリックする 「エクスポートファイル形式」で「Personal Information Exchange - PKCS #12 (.PFX)」を選択し、「次へ」をクリックする 「セキュリティ」で「パスワード」にチェックを入れ、パスワードを入力する 「エクスポートファイル」で保存先を指定し、「次へ」をクリックする 問題なければ「完了」をクリックする 「正しくエクスポートされました」と表示されたら「完了」をクリックする 同じように、「証明書 - ローカル コンピューター」&gt;「信頼されたルート証明機関」に証明書が追加されていることを確認する追加された証明書を右クリックし、「全てのタスク」&gt;「エクスポート」をクリックする 「証明書のエクスポートウィザード」が表示されるので、「次へ」をクリックする 「エクスポートファイル形式」で「DER encoded binary X.509 (.CER)」を選択し、「次へ」をクリックする 「エクスポートファイル」で保存先を指定し、「次へ」をクリックする 問題なければ「完了」をクリックする 「正しくエクスポートされました」と表示されたら「完了」をクリックする1.5 証明書をADDS,　ADFSにコピー 「ネットワーと共有センター」&gt;「共有の詳細設定」&gt;「ドメイン(現在のプロファイル)」で、ネットワーク探索、ファイル共有、プリンター共有を有効にする ADDS, ADFSでエクスポートした証明書をローカルフォルダにコピーする " }, { "title": "[wip] Active Directoryの構築 2 (ADCS編)", "url": "/posts/2024-06-05-active-directory-2-adcs/", "categories": "wip", "tags": "wip, Active Directory", "date": "2024-06-05 00:00:00 +0900", "snippet": "ADCS構築0. ADCSをADに参加させるADDSの操作 サーバーマネージャーの「ツール」&gt;「Active Directory ユーザーとコンピューター」をクリックする AD用のOUを右クリックし、「新規作成」&gt;「ユーザー」をクリックする ADCS用のユーザーを作成するここでは、adcsというユーザーを作成するユーザーログオン名にはadcs...", "content": "ADCS構築0. ADCSをADに参加させるADDSの操作 サーバーマネージャーの「ツール」&gt;「Active Directory ユーザーとコンピューター」をクリックする AD用のOUを右クリックし、「新規作成」&gt;「ユーザー」をクリックする ADCS用のユーザーを作成するここでは、adcsというユーザーを作成するユーザーログオン名にはadcsを入力し、「次へ」をクリックする 作成したADCS用のユーザーを右クリックし、「プロパティ」をクリックする 「所属するグループ」タブをクリックし、「追加」をクリックする グループを検索して追加するために、「詳細設定」をクリックする 共通クエリの名前に「Domain Admins」を入力し、「検索」をクリックし、「Domain Admins」を選択し、「OK」をクリックする 同じように「Enterprise Admins」を追加する 「OK」をクリックする 「適用」をクリックし、「OK」をクリックして、プロパティを閉じる 参考: Domain AdminsとEnterprise Adminsとは Domain Admins: ドメイン全体の管理者権限を持つグループ Enterprise Admins: フォレスト全体の管理者権限を持つグループADCSはドメイン全体の管理者権限が必要なため、Domain AdminsとEnterprise Adminsに追加する参考: Install the Certification AuthorityADCSの操作 ホスト名をADCSに変更する Rename-Computer -NewName \"ADCS\" IPアドレスを192.168.10.102に変更する Get-NetIPAddress | New-NetIPAddress -AddressFamily IPv4 -IPAddress 192.168.10.100 -PrefixLength 24 DNSをADDSに向ける Set-DnsClientServerAddress -InterfaceIndex 4 -ServerAddresses 192.168.10.100 「システムの詳細設定」を開き、「コンピューター名」タブをクリックし、「変更」をクリックする 「コンピューター名/ドメインの変更」で「ドメインに参加」を選択し、「ドメイン名」にr74tech.localを入力し、「OK」をクリックする ドメイン参加のためにユーザー名とパスワードを入力し、「OK」をクリックする 「OK」をクリックする 「他のユーザーでログイン」をクリックし、サインイン先がNetBIOS ドメイン名になっていることを確認し、ログインする1. 証明書サービスのインストール サーバーマネージャーの「管理」&gt;「役割と機能の追加」をクリックする 「役割と機能の追加ウィザード」が表示されるので、「次へ」をクリックする 「インストールの種類」で「役割ベースまたは機能ベースのインストール」を選択し、「次へ」をクリックする 「サーバーの選択」で「サーバー」を選択し、対象のサーバーを選択し、「次へ」をクリックする 「役割の選択」で「Active Directory 証明書サービス」を選択する ポップアップが表示されるので「機能の追加」をクリックする 「機能の選択」では追加するものはないので「次へ」をクリックする 「Active Directory 証明書サービス」の説明が表示されるので「次へ」をクリックする 「役割サービスの選択」で「証明機関」を選択し、「次へ」をクリックする 「インストールオプション」で「再起動後に自動的に必要なサービスを追加する」はチェックを入れ、「インストール」をクリックするここでは、撮影のためにチェックを入れていないが、実際にはチェックを入れることを推奨する インストールが完了すると「構成が必要です。HOSTでインストールが正常に完了しました」と表示されるので、「閉じる」をクリックする 2. 証明書サービスの構成 サーバーマネージャーの「通知」に展開後構成タスクが表示されるので、「対象サーバーにActive Directory 証明書サービスを構成する」をクリックする 「資格情報」で&lt;NetBIOS ドメイン名&gt;\\adcsを入力し、「次へ」をクリックする 「役割サービスの選択」で「証明機関」を選択し、「次へ」をクリックする 「CAのセットアップ」で「エンタープライズCA」を選択し、「次へ」をクリックする 「CAの種類」で「ルートCA」を選択し、「次へ」をクリックする 「秘密キー」で「新しい秘密キーを作成する」を選択し、「次へ」をクリックする 「暗号化」では「SHA256」を選択し、「次へ」をクリックする基本的には暗号化プロバイダーはデフォルトのRSA#Microsoft Software Key Storage Providerから変更する必要はないキーの長さは2048ビット以上を推奨し、ハッシュアルゴリズムはMD5などの脆弱なアルゴリズムは使用しない方が良い 「CAの名前」では基本的にはデフォルトのままで問題ないが、必要に応じて変更する 「CAの証明書の有効期間」では「5年」を選択し、「次へ」をクリックする 「データベースの場所」ではデフォルトのままで問題ないが、必要に応じて変更する 「概要」で設定内容を確認し、「構成」をクリックする 「構成が完了しました」が表示されるので、「閉じる」をクリックする " }, { "title": "[wip] Active Directoryの構築 1 (ADDS編)", "url": "/posts/2024-06-05-active-directory-1-adds/", "categories": "wip", "tags": "wip, Active Directory", "date": "2024-06-05 00:00:00 +0900", "snippet": "ADDS構築0. 事前準備 ホスト名をADDCに変更する Rename-Computer -NewName \"ADDC\" IPアドレスを192.168.10.100に変更する Get-NetIPAddress | New-NetIPAddress -AddressFamily IPv4 -IPAddress 192.168.10.100 -PrefixLength...", "content": "ADDS構築0. 事前準備 ホスト名をADDCに変更する Rename-Computer -NewName \"ADDC\" IPアドレスを192.168.10.100に変更する Get-NetIPAddress | New-NetIPAddress -AddressFamily IPv4 -IPAddress 192.168.10.100 -PrefixLength 24 インターネットアダプターが複数ある場合は、InterfaceIndexを指定して変更する Get-NetIPAddress | New-NetIPAddress -InterfaceIndex 4 -AddressFamily IPv4 -IPAddress 参考: ネットワークアダプタの確認/設定Get-NetAdapter: ネットワークアダプタの一覧を表示する Get-NetAdapter​Name InterfaceDescription ifIndex Status MacAddress LinkSpeed---- -------------------- ------- ------ ---------- ---------Ethernet0 Intel(R) 82574L Gigabit Network Conn... 4 Up 00-0C-29-3D-5E-1. 1 Gbps 1. Active Directoryの機能を有効化する Windows Server 2019上で「サーバーマネージャー」を開き、右上の「管理」&gt; 「役割と機能の追加」をクリックする 「役割と機能の追加ウィザード」が表示されるので、「次へ」をクリックする 「インストールの種類」で「役割ベースまたは機能ベースのインストール」を選択し、「次へ」をクリックする 「サーバーの選択」で「サーバー」を選択し、対象のサーバーを選択し、「次へ」をクリックする 「役割の選択」で「Active Directory ドメインサービス」を選択する ポップアップが表示されるので「機能の追加」をクリックする このタイミングで「DNSサーバー」もインストールする 同じようにポップアップが表示されるので「機能の追加」をクリックする 「機能の選択」では追加するものはないので「次へ」をクリックする 「Active Directory ドメインサービス」の説明が表示されるので「次へ」をクリックする 「DNSサーバー」の説明が表示されるので「次へ」をクリックする 「インストールオプション」で「再起動後に自動的に必要なサービスを追加する」はチェックを入れ、「インストール」をクリックする今回は撮影のためにチェックを入れていないが、実際にはチェックを入れることを推奨する インストールが完了すると「構成が必要です。HOSTでインストールが正常に完了しました」と表示されるので、「閉じる」をクリックする 2. Active Directoryの昇格 サーバーマネージャーの「通知」に展開後構成タスクが表示されるので、「このサーバーをドメイン コントローラーに昇格する」をクリックする 「配置構成」で「新しいフォレストの追加」を選択し、「ルートドメイン名」を入力し、「次へ」をクリックするここではr74tech.localを入力している。今回はEntra ADとのハイブリッド環境を構築するため、TLDは.localを使用し、最終的に代替UPNサフィックス設定する予定である。 「ドメインコントローラーオプション」で「ディレクトリサービスの復元パスワード」を入力し、「次へ」をクリックする フォレストの機能レベル: Windows Server 201. 今回はWindows10, Windows Server 2019の環境を構築するため、Windows Server 2016のままで問題ない ディレクトリサービスの復元パスワード: 復元パスワードを入力する 復元パスワードはドメインコントローラーの復元時に使用するため、忘れないように注意する DNS委任を行わない場合は「次へ」をクリックする 「追加のオプション」で「次へ」をクリックする「NetBIOS ドメイン名」は自動入力されるため、入力する必要はない 「データベースのフォルダー」「ログファイルのフォルダー」「SYSVOLフォルダー」の場所を確認し「次へ」をクリックする。 「オプションの確認」で設定内容を確認し、「次へ」をクリックする 「前提条件のチェック」でエラーがないことを確認し、「インストール」をクリックする インストールが完了すると「このサーバーはドメインコントローラーとして正常に構成されました」と表示されるので、「閉じる」をクリックする。再起動を促されるので「再起動」をクリックする 再起動後、Ctrl + Alt + Deleteを押し、&lt;NetBIOS ドメイン名&gt;\\Administratorでログインする3. ドメインユーザーの作成 サーバーマネージャーの「ツール」&gt;「Active Directory ユーザーとコンピューター」をクリックする r74tech.localを右クリックし、「新規作成」から「組織単位」を選択し、AD用のOUを作成する 「名前」に組織で識別可能なわかりやすい名前を入力し、「OK」をクリックする 作成したOUを右クリックし、「新規作成」&gt;「ユーザー」をクリックする 「姓」か「名」のいずれかにに識別可能なわかりやすい名前を入力し、「ユーザーログオン名」にも同じように入力し、「次へ」をクリックする 「パスワード」を入力し、「次へ」をクリックする「パスワードを無期限にする」のみチェックを入れておく 問題なければ「完了」をクリックする 作成したOU配下にユーザーが作成されていることを確認する 4. ドメインユーザーの参加 ホスト名をTESTUSER01に変更する Rename-Computer -NewName \"TESTUSER01\" IPアドレスを192.168.10.110に変更する Get-NetIPAddress | New-NetIPAddress -AddressFamily IPv4 -IPAddress 192.168.10.110 -PrefixLength 24 DNSをADDSに向ける Set-DnsClientServerAddress -InterfaceIndex 4 -ServerAddresses 192.168.10.100 ネットワーク設定が正常に行われていることを確認する Win + Rでsysdm.cpl(システムのプロパティ)を開いて、変更をクリックし、所属ドメインをr74tech.localに変更する 3.で作成したユーザーでログインする net userコマンドでユーザーが参加していることを確認する net user /domain ipconfig /allでWindows IP構成が正常に設定されていることを確認する ipconfig /all " }, { "title": "[wip] NginxとDjangoでShibboleth認証を実装する", "url": "/posts/2024-03-21-shibboleth-nginx-django/", "categories": "wip", "tags": "django, shibboleth, wip", "date": "2024-03-21 00:00:00 +0900", "snippet": "", "content": "" }, { "title": "[wip] Breaching Active Directory", "url": "/posts/2024-03-06-breachingad/", "categories": "wip", "tags": "Active Directory, tryhackme, wip", "date": "2024-03-06 00:00:00 +0900", "snippet": "邦訳: Active Directoryへの侵入ADの設定ミスをついて特権昇格や横断的移動、目的実行などを行うにはまず、初期アクセスが必要となる。このRoomでは、ADに侵入するための方法をいくつか紹介する。 NTLM認証サービス LDAPバインド資格情報 認証リレー Microsoft Deployment Toolkit 設定ファイルTask 1: Introduction t...", "content": "邦訳: Active Directoryへの侵入ADの設定ミスをついて特権昇格や横断的移動、目的実行などを行うにはまず、初期アクセスが必要となる。このRoomでは、ADに侵入するための方法をいくつか紹介する。 NTLM認証サービス LDAPバインド資格情報 認証リレー Microsoft Deployment Toolkit 設定ファイルTask 1: Introduction to AD Breachesまずは、ネットワーク内の特定のサーバーやリソースにアクセスするために必要な名前解決を行う設定から始める。これにより、ドメイン名をIPアドレスに変換し、ネットワーク通信の正しいルーティングを確保する。下記のコマンドは、この名前解決プロセスを設定するために使用され、THMDCIP変数には、TryHackMeのドメインコントローラーのIPアドレスが格納され、このアドレスがDNSサーバーとして機能する。これにより、za.tryhackme.comドメイン内のホストに対するクエリが正確に解決され、タスクやチャレンジに必要なネットワークリソースへのアクセスが可能になる。$ THMDCIP=10.200.28.101$ systemd-resolve --interface breachad --set-dns $THMDCIP --set-domain za.tryhackme.com コマンド部分 説明 systemd-resolve DNS設定やクエリ実行に関するコマンドラインツール –interface breachad 操作を適用するネットワークインターフェースを指定 –set-dns $THMDCIP 使用するDNSサーバーのIPアドレスを設定 –set-domain za.tryhackme.com 検索ドメインを設定 ※ 検索ドメイン: FQDNではないホスト名に対して自動的に追加されるドメイン。 I have completed the AD basics room and am ready to learn about AD breaching techniques. No answer needed I have connected to the network and configured DNS. No answer needed Task2: OSINT and Phishing I understand OSINT and how it can be used to breach AD(ADを侵害するために使用できるOSINTを理解している) No answer needed I understand Phishing and how it can be used to breach AD(ADを侵害するために使用できるフィッシングを理解している) No answer needed What popular website can be used to verify if your email address or password has ever been exposed in a publicly disclosed data breach?(自分のメールアドレスやパスワードが、一般に公開されたデータ流出事件で流出したことがあるかどうかを確認するために、人気のあるウェブサイトはなんだろうか？) HaveIBeenPwned Task 3: NTLM Authenticated Services What is the name of the challenge-response authentication mechanism that uses NTLM?(NTLMを使用したチャレンジ-レスポンス認証メカニズムの名前は何か？) NetNtlm What is the username of the third valid credential pair found by the password spraying script?(パスワードスプレーのスクリプトで見つかった3番目の有効な資格情報のユーザー名は何か？) gordon.stevens How many valid credentials pairs were found by the password spraying script?(パスワードスプレーのスクリプトで見つかった有効な資格情報のペアは何組か？) 4 What is the message displayed by the web application when authenticating with a valid credential pair?(有効な資格情報のペアで認証すると、Webアプリケーションに表示されるメッセージは何か？) Hello World Task 4: LDAP Bind Credentials What type of attack can be performed against LDAP Authentication systems not commonly found against Windows Authentication systems? LDAP Pass-back Attack What two authentication mechanisms do we allow on our rogue LDAP server to downgrade the authentication and make it clear text? LOGIN,PLAIN What is the password associated with the svcLDAP account? tryhackmeldappass1@ Task 5: Authentication Relay What is the name of the tool we can use to poison and capture authentication requests on the network? Responder What is the username associated with the challenge that was captured? svcFileCopy What is the value of the cracked password associated with the challenge that was captured? FPassword1! Task 6: Microsoft Deployment Toolkit What Microsoft tool is used to create and host PXE Boot images in organisations? Microsoft Deployment Toolkit What network protocol is used for recovery of files from the MDT server? TFTP What is the username associated with the account that was stored in the PXE Boot image? svcMDT What is the password associated with the account that was stored in the PXE Boot image? PXEBootSecure1@ While you should make sure to cleanup you user directory that you created at the start of the task, if you try you will notice that you get an access denied error. Don’t worry, a script will help with the cleanup process but remember when you are doing assessments to always perform cleanup. No answer needed Task 7: Configuration Files What type of files often contain stored credentials on hosts? Configuration Files What is the name of the McAfee database that stores configuration including credentials used to connect to the orchestrator? ma.db What table in this database stores the credentials of the orchestrator? AGENT_REPOSITORIES What is the username of the AD account associated with the McAfee service? svcAV What is the password of the AD account associated with the McAfee service? MyStrongPassword! Task 8: Conclusion I understand how configuration changes can help prevent AD breaches. No answer needed " }, { "title": "OG画像を動的に生成する", "url": "/posts/2024-02-29-generate-og/", "categories": "web", "tags": "front", "date": "2024-02-29 00:00:00 +0900", "snippet": "Twitter で見かける、技術系記事を自サイトでホストしている人達は華やかな OG 画像を載せている。実際、リンクを共有したときに表示されるのであれば記事の内容が一目でわかる。このサイトは Jekyll で生成しており、Github Actions+Ruby で OG 画像を生成するとデプロイに非常に時間がかかるため、satoriと@resvg/resvg-jsを用いて OG 画像を生成す...", "content": "Twitter で見かける、技術系記事を自サイトでホストしている人達は華やかな OG 画像を載せている。実際、リンクを共有したときに表示されるのであれば記事の内容が一目でわかる。このサイトは Jekyll で生成しており、Github Actions+Ruby で OG 画像を生成するとデプロイに非常に時間がかかるため、satoriと@resvg/resvg-jsを用いて OG 画像を生成する方法を考えた。環境@resvg/resvg-js 2.6.0gray-matter 4.0.3satori 0.10.13satori-html 0.3.2実装markdown ファイルは以下のように、frontmatter を事前に設定しておく。---title: sampleslug: 2024-02-29-sampletags: - sample - test---slug は記事の URL になる他、OG 画像のファイル名にもなる。また、tags は OG 画像の説明に使う。以下のスクリプトは、\\_posts ディレクトリにあるファイルを読み込み、frontmatter を元に OG 画像を生成する。import { readdir, readFile, writeFile } from \"fs/promises\";import { join } from \"path\";import matter from \"gray-matter\";import { Resvg } from \"@resvg/resvg-js\";import { html } from \"satori-html\";import satori from \"satori\";const dir = \"./_posts\";try { const files = await readdir(dir); for (const file of files) { const content = await readFile(join(dir, file), \"utf8\"); const result = matter(content); await generateOgImage({ title: result.data.title, slug: result.data.slug.toLowerCase(), description: result.data.tags ? result.data.tags.join(\", \") : \"\", }); }} catch (err) { console.error(\"Error:\", err);}async function generateOgImage({ title, slug, description }) { const svg = await satori( html` &lt;style&gt; div { display: flex; } .wrapper { display: flex; flex-direction: column; background-color: #0f0d0e; height: 630px; padding: 80px; } .top { display: flex; justify-content: space-between; align-items: center; } .bottom { display: flex; flex-direction: column; justify-content: flex-end; flex-basis: 100%; width: 90%; padding-bottom: 40px; } .install { font-size: 32px; font-family: \"Fira Code\"; color: #f9f4da; } .install span { color: #0ba95b; padding-right: 16px; } .title { margin-top: 16px; font-size: 64px; font-family: \"Zen Kaku Gothic New\"; font-weight: 400; color: #12b5e5; word-break: auto-phrase; } .description { margin-top: 16px; font-family: \"Outfit\"; font-size: 40px; font-weight: 400; color: #f9f4da; } &lt;/style&gt; &lt;div class=\"wrapper\"&gt; &lt;div class=\"top\"&gt; &lt;div class=\"install\"&gt;&lt;span&gt;&gt;&lt;/span&gt; pnpm i @r74tech/blog&lt;/div&gt; &lt;/div&gt; &lt;div class=\"bottom\"&gt; &lt;div class=\"title\"&gt;${title}&lt;/div&gt; &lt;div class=\"description\"&gt;${description}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;`, { fonts: [ { name: \"Outfit\", data: await readFile( new URL(\"./assets/fonts/outfit-regular.ttf\", import.meta.url) ), weight: \"400\", style: \"normal\", }, { name: \"Fira Code\", data: await readFile( new URL(\"./assets/fonts/firacode-regular.ttf\", import.meta.url) ), weight: \"400\", style: \"normal\", }, { name: \"Zen Kaku Gothic New\", data: await readFile( new URL( \"./assets/fonts/ZenKakuGothicNew-Regular.ttf\", import.meta.url ) ), weight: \"400\", style: \"normal\", }, ], width: 1200, height: 630, } ); const resvg = new Resvg(svg, { fitTo: { mode: \"original\", }, }); const pngData = resvg.render(); const pngBuffer = pngData.asPng(); await writeFile( new URL(`./assets/img/og/${slug}.png`, import.meta.url), pngBuffer );}Jekyll 側の対応このブログのテーマ側で、jekyll-seo-tagが使われているため、frontmatter にimageを追加することで OG 画像を指定できる。ただし、画像を追加すると記事の初めに画像が表示されるため、_layouts/post.htmlを修正する必要がある。該当コードこのブログでは、showを追加して OG 画像を表示するかどうかを指定できるようにした。参考文献 HonoX で satori を使って OG イメージも SSG する" } ]
